#include<bits/stdc++.h>
#include <iostream>
using namespace std;

/* segment trees 
operations : get(i) and add(l,r,v) 
get(i)   : return a[i]
add(l,r,v) : Adding v to all elements in the range from l to r 
*/

int a[10001];
int t[1000001];
int n;

void build(int ls,int rs,int inode)
{
    /* we will build this slightly different from the traditional segment tree used to 
    calculate the sum on a segment .*/
    if((rs-ls)==1)
    {
        t[inode]=a[ls];
        return;
    }
    else
    {
        int mid = ls + (rs-ls)/2;
        build(ls,mid,2*inode+1);
        build(mid,rs,2*inode+2);
    }
    //t[inode] = t[2*inode+1] + t[2*inode+2];
    /* we will have the above line in the sum segment tree.*/
    /*we will only build the leaf nodes in this function.*/
}
void add(int l,int r,int v,int inode,int ls,int rs)
{
    if(ls>=r || rs<=l)
    {
        //completely outside 
        return;
    }
    else if(l<=ls && rs<=r)
    {
        //current inode range is completely inside our range (l,r).Note what is inside what 
        t[inode]+=v;
        /*try to think this condition interms of the example provided.*/
    }
    else
    {
        int mid  = ls + (rs-ls)/2;
        add(l,r,v,2*inode+1,ls,mid);
        add(l,r,v,2*inode+2,mid,rs);
    }
}

int get(int i,int inode,int ls,int rs)
{
    if((rs-ls)==1)
    return t[inode];
    else
    {
        int mid = ls + (rs-ls)/2;
        if(i<mid)
        return t[inode] + get(i,2*inode+1,ls,mid);
        else
        return t[inode] + get(i,2*inode+2,mid,rs);
    }
}

int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
    cin>>a[i];
    build(0,n,0);
    add(0,4,5,0,0,n);  // a[0]+=5 a[1]+=5 a[2]+=5 a[3]+=5
    int ans = get(0,0,0,n); //a[i]
    cout<<ans<<endl;
}
